<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Explaining <code>micromatch</code> package</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Explaining micromatch package}
-->

<h1>Explaining <code>micromatch</code> package</h1>

<p>The <code>micromatch</code> package provides a set of utilities and functions to ease the task of statistical matching of official microdata files.</p>

<h2>What is statistical matching?</h2>

<p>Statistical matching (also known as data fusion data merging or synthetic matching) is set of techniques for providing joint information on variables or indicators collected through multiple sources, usually, surveys drawn from the same population. The potential benefits of this approach lie in the possibility to enhance the complementary use and analytical potential of existing data sources. (A. Leulescu &amp; M. Agafitei, 2013).</p>

<h3>The starting point</h3>

<p>The statistical matching task usually begins with two independent survey samples from the same population of interest, each of which produces measures regarding specific questions (for example, living styles and wages), but sharing a block of common variables (usually sociodemographic variables such as the age, sex, or social status), see Fig.1. The basic assumption is that the number of individuals or units appearing in both samples (i.e., the overlap) is negligible. In this respect, the fundamental difference with respect to other methods such as record linkage is that, in the latter, we have identical units that we want to match exactly, while in statistical matching we <em>know</em> the units are different, but we <em>wish</em> to find similar ones. </p>

<p><img src="fig1.png" alt="alt text"/></p>

<h3>When should we consider using micromatch?</h3>

<p>The user will be ready to use <code>micromatch</code> when having two separate files, A and B, with <em>distinct units</em> referred to the <em>same population of interest</em>, having two sets of distinct variables in each file (which we call <em>specific variables</em>), and sharing a common block of variables (which we call <em>common variables</em>). The user wishes to do specific statistical analyses that combine variables coming from the distinct files or sources, and faces the problem of lacking observations with information for all the variables. </p>

<p>By applying statistical matching methods, the user will typically obtain either a synthetic file containing information on all the variables and all units from both sources (so in this case statistical matching could be viewed as a kind of missing data imputation procedure). Sometimes, when only two variables in separate files are of specific interest, the user could more efficiently estimate a contingency table or correlation coefficient, or any parameter of interest regarding only those two variables of interest. The former is named the <em>micro</em> approach, while the latter is the <em>macro</em> approach.</p>

<p>Also, the distiction of <em>donor</em> and <em>recipient</em> files is useful if a micro method is applied (that is, a synthetic file is produced): sometimes, only one of the files (the one having more observations, the <em>recipient</em>) is filled with the variables from the other file (the <em>donor</em>). In this case, the synthetic file will have as much observations as the recipient file.</p>

<p>The statistical matching methods efficiently use the information provided by the block of common variables in order to produce a plausible or valid synthetic file.</p>

<h3>What is the particular solution implemented in <code>micromatch</code>?</h3>

<p>The functions currently available in <code>micromatch</code> are organized in four families, which closely follow the main steps in the statistical matching process, see Fig 2.</p>

<p><img src="fig2.png" alt="alt text"/></p>

<h3>Functions by families in <code>micromatch</code></h3>

<h4>Family 1: Specify matching objectives</h4>

<p>First of all the matching objectives must be specified, which means that the user has to define:</p>

<ul>
<li>A list of common variables (i.e. variables which are, by definition, identical accross the files. Ex. age, sex, education level)</li>
<li>A list of specific variables for the first file (usually called the )</li>
<li>A list of specific variables for the second file</li>
<li><p>Ideally, the desired result (a synthetic file or contingency table, for example)</p>

<pre><code>* Funciones implementadas: en este momento solamente disponemos de la clase `matchdesign` que encapsularía toda esta información así como del método `describe`, que la extraería de un objeto de esta clase.
</code></pre></li>
</ul>

<h4>Family 2: Select matching variables</h4>

<p>In this step one most select a set of variables that will be used by the matching procedure, such that:</p>

<ul>
<li>They are concordant across the files; i.e. besides having the same definition (i.e. comparable questions in the questionnaires), they produce the same observed marginal distributions.</li>
<li><p>They have predictive value with respect to the specific variables (in each file) </p>

<pre><code>* Funciones implementadas:

*compareVar*
Compara la distribución marginal observada para una única variable categórica en los dos ficheros. Produce gráficos de barras y medidas empíricas como la distancia de Hellinger. Se pueden emplear pesos, y las tablas generadas. Futuros desarrollos: extenderlo a variables continuas.

*compareMultivar*
Extiende la anterior para poder analizar la concordancia de distribuciones al condicionar por alguna otra variable, generalmente, estratos (como la edad y sexo). La lógica es la misma. Futuros desarrollos: los mismos. Adicionalmente, se debería estudiar la posibilidad de emplear técnicas multivariantes para comparar espacios factoriales, por ejemplo, un análisis de correspondencias y el coeficiente RV. esto es muy fácil de hacer con FactoMineR. También aportaría una visualización del espacio de variables comunes, donde además podríamos proyectar las específicas.

*predictvalue*
Solamente válida para variables categóricas, mide el valor predictivo de una variable común cada vez para una variable específica dada. Produce valores dados por la función `pw.assoc` de `StatMatch`: la V de Cramer, etc, y se le añade un gráfico de mosaico dado por `structplot`. Con un `sapply` se puede analizar el valor predictivo de una lista de variables comunes en una sola iteración. Futuros desarrollos: esta aproximación univariante es demasido básica, sería deseable poder hacer modelos de regresión o bien implementar el random forest (fácil con `randomForest`), o algo similar, pero con fundamento estadística adecuado.

*uncertvarxvary*
Aún en modo de prueba, implementa la idea reflejada en StatMatch de seleccionar aquellas variables que más reduzcan la incertidumbre en cuanto a las distribuciones conjuntas no-observadas. También es un elemento esencial de la validación, con lo que también pertenecería a la Familia 4
</code></pre></li>
</ul>

<h4>Family 3: Apply matching method</h4>

<p>At this step a matching method is applied to either a synthetic file or a macro parameter estimation.</p>

<pre><code>    *Funciones implementadas:

    *nnhdbystrata*

    Básicamente es la nearest-neighbour hot-deck implementada en StatMatch, función `NND.hotdeck`, pero lo que aporta es que se efectúa un hot-deck para un estrato dado. Esto nos da la posibilidad de aplicar el matching por estratos de forma rápida usando un solo `sapply` que itere sobre todos los estratos. Futuros desarrollos: queda implementar una función similar que emplee funciones de `mice` (idealmente predictive mean matching que al parecer es muy robusto). Entonces seguramente será necesario crear una función intermedia que genere un fichero concatenado para pasar a `mice`.
</code></pre>

<h4>Family 4: Validation</h4>

<p>At this step a thorough validation of results must be performed.</p>

<pre><code>    *Se pueden utilizar `compareVar` y `compareMultiVar` para comparar las distribuciones de variables observadas vs imputadas, una vez producido el fichero sintético. Sería muy interesante añadir funciones para poder hacer ejercicios de simulación (que servirían para probar si el matching es robusto, entender mejor sus tripas, etc). Hay referencias al respecto, y darían un valor añadido ya que en `StatMatch` no hay nada parecido.
</code></pre>

<h3>Ejemplo de uso</h3>

<h4>Cargar paquete y datos</h4>

<p>Los datos de dos encuestas de Eustat, ECV y PRA, se han cargado en el propio paquete micromatch. </p>

<pre><code>    * Está pendiente documentarlas: parece que no funciona el script ecv-data.R
</code></pre>

<p><strong>Encuestas de Eustat</strong>
Datos en el mismo micromatch:
1. PRA: Población en relación con la actividad
2. ECV: Encuesta de condiciones de vida</p>

<pre><code>## [1] 4749  417
</code></pre>

<pre><code>## [1] 10865    73
</code></pre>

<h3>Etapa 1: Definir objetivos</h3>

<p>Primero definir lo que se quiere hacer:</p>

<ul>
<li><em>Variables comunes candidatas</em>: en principio, se introducen todas las que podrian valer.
Luego hay que descartar las que no son concordantes (distribuciones muy distintas), y las que no tienen capacidad predictiva (no tienen relación con las variables específicas)</li>
<li><em>Variables especificas</em></li>
<li>Idealmente, <em>objetivo del enlace</em>: lo que se quiere obtener (tablas, fichero sintético, etc)</li>
</ul>

<p><em>Listas de variables</em></p>

<pre><code class="r">#variables comunes candidatas: las variables que comparten ecv y pra
#aun no sabemos si seran coherentes; lo son en cuanto a la definicion
#(preguntas de los cuestionarios), pero hay que ver si las distribuciones
#observadas coinciden.
#Esto hay que analizarlo no solo en general, sino en funcion de los valores 
#de otras variables, por ejemplo, por edad y sexo
#
varCom &lt;- c(&quot;ED&quot;, #Edad: estrato
            &quot;S&quot;,  #Sexo: estrato
            &quot;TF2&quot;, #Tamanyo familiar
            &quot;EST&quot;, #Estudiante si (1) o no (0)
            &quot;OCP&quot;, #Ocupado si/no
            &quot;PAR&quot;, #Parado si/no
            &quot;INA&quot;, #Inactivo si/no
            &quot;BUSQ&quot;, #Buscando empleo si/no
            &quot;DOM.com2&quot;) #Dedicacion a las tareas domesticas
#
#variables especificas ECV
varEsp &lt;- c(&quot;SAL&quot;,  #condiciones de salud
            &quot;IDM&quot;,  #conocimiento idiomas
            #&quot;DOM&quot;,  #(la ponemos como variable comun) dedicacion tareas domesticas
            &quot;NIN&quot;, #cuidado de ninyos
            &quot;VAC&quot;, #lugar de vacaciones
            &quot;LIB&quot;, 
            &quot;RELI&quot;, 
            &quot;RELF&quot;, 
            &quot;EQP&quot;,
            &quot;VIV&quot;,
            &quot;VEH&quot;,
            &quot;SRV&quot;, 
            &quot;AMB&quot;,
            &quot;DOM2&quot;,
            &quot;ECO&quot;,
            &quot;ING&quot;,
            &quot;FIN&quot; )
#variable especifica de PRA
vary &lt;- &quot;PRA22&quot;
</code></pre>

<h3>Etapa 2: Selección de variables</h3>

<p><em>Coherencia de fuentes</em></p>

<p><strong>Función: compareVar</strong></p>

<p>Univariate comparisons: Compares one variable at a time</p>

<p>Only check first 2 variables.</p>

<pre><code class="r">#consultar documentacion: ?compareVar
#dar valores a los parametros fijos
fileA &lt;- ecv
fileB &lt;- pra
wA &lt;- wB &lt;- &quot;calELE&quot; #variable de peso calibrada
#
# all comparisons for a list of common vars at once
#absolute values, no plotting, no empirical measures
sapply(X=1:2, FUN=function(x){
        print(paste(&#39;Variable: &#39;,varCom[x]))
        varA &lt;- varB &lt;- varCom[x]
        c &lt;- compareVar(varA=varA, varB=varB,fileA=fileA,fileB=fileB,wA=wA, wB=wB,plot=FALSE,measures=FALSE,type=&quot;abs&quot;)
        print(c)
})
</code></pre>

<pre><code>## [1] &quot;Variable:  ED&quot;
## $`table for file #1`
## x1
## (15,24] (24,34] (34,44] (44,54] (54,64]     65+     Sum 
##  177684  327581  355344  325660  273009  393715 1852993 
## 
## $`table for file #2`
## x2
## (15,24] (24,34] (34,44] (44,54] (54,64]     65+     Sum 
##  171921  319528  355384  328303  270392  423928 1869456 
## 
## $measures
## NULL
## 
## [1] &quot;Variable:  S&quot;
## $`table for file #1`
## x1
##       H       M     Sum 
##  911419  941573 1852992 
## 
## $`table for file #2`
## x2
##       H       M     Sum 
##  903821  965634 1869455 
## 
## $measures
## NULL
</code></pre>

<pre><code>##                   [,1]      [,2]     
## table for file #1 Numeric,7 Numeric,3
## table for file #2 Numeric,7 Numeric,3
## measures          NULL      NULL
</code></pre>

<pre><code class="r">#relative values, plotting, with empirical measures (Hellinger&#39;s Distance, etc)
sapply(X=1:2, FUN=function(x){
        print(paste(&#39;Variable: &#39;,varCom[x]))
        varA &lt;- varB &lt;- varCom[x]
        #relative values, with plot
        c&lt;- compareVar(varA=varA, varB=varB,fileA=fileA,fileB=fileB,wA=wA, wB=wB,plot=TRUE,measures=TRUE,type=&quot;rel&quot;)
        print(c)
})
</code></pre>

<pre><code>## [1] &quot;Variable:  ED&quot;
</code></pre>

<pre><code>## ymax not defined: adjusting position using y instead
</code></pre>

<p><img src="figure/concordancia1.png" alt="plot of chunk concordancia"/> </p>

<pre><code>## $`table for file #1`
## x1
## (15,24] (24,34] (34,44] (44,54] (54,64]     65+     Sum 
##    9.59   17.68   19.18   17.57   14.73   21.25  100.00 
## 
## $`table for file #2`
## x2
## (15,24] (24,34] (34,44] (44,54] (54,64]     65+     Sum 
##    9.20   17.09   19.01   17.56   14.46   22.68  100.00 
## 
## $measures
##     tvd overlap   Bhatt    Hell 
## 0.01429 0.98571 0.99983 0.01302 
## 
## [1] &quot;Variable:  S&quot;
</code></pre>

<pre><code>## ymax not defined: adjusting position using y instead
</code></pre>

<p><img src="figure/concordancia2.png" alt="plot of chunk concordancia"/> </p>

<pre><code>## $`table for file #1`
## x1
##      H      M    Sum 
##  49.19  50.81 100.00 
## 
## $`table for file #2`
## x2
##      H      M    Sum 
##  48.35  51.65 100.00 
## 
## $measures
##      tvd  overlap    Bhatt     Hell 
## 0.008396 0.991604 0.999965 0.005939
</code></pre>

<pre><code>##                   [,1]      [,2]     
## table for file #1 Numeric,7 Numeric,3
## table for file #2 Numeric,7 Numeric,3
## measures          Numeric,4 Numeric,4
</code></pre>

<pre><code class="r">#To analyze all variables in varCom list, use sapply(X=1:length(varCom), FUN=...)
</code></pre>

<p><em>Coherence of variables by strata (facets) in separate sources</em></p>

<p><strong>Función: compareMultivar</strong></p>

<p>Elegimos una variable de muestra: el indicador de Estudiante S/N.
Para estudiar todas a la vez se emplearía, como antes, un sapply.</p>

<pre><code class="r">#consultar documentacion ?compareMultivar
var1A &lt;- var1B &lt;- varCom[2] #S estrato
var2A &lt;- var2B &lt;- varCom[4] #variable a estudiar (dependiente)
var3A &lt;- var3B &lt;- varCom[1] #ED  estrato
#absolute values, no measures, no plotting
compareMultivar(var1A=var1A,var1B=var1B,var2A=var2A,var2B=var2B,var3A=var3A,var3B=var3B,fileA=fileA, fileB=fileB, type=&quot;abs&quot;,measures=FALSE,wA=wA, wB=wB, plot=FALSE)
</code></pre>

<pre><code>## $`table for file #1`
##          z1 (15,24] (24,34] (34,44] (44,54] (54,64]    65+
## x1 y1                                                     
## H  FALSE      40566  153508  179269  155768  133761 173095
##    TRUE       51073   13199    2340    7283     896    660
## M  FALSE      36277  149322  164325  158928  136252 218578
##    TRUE       49768   11552    9409    3680    2099   1382
## 
## $`table for file #2`
##          z2 (15,24] (24,34] (34,44] (44,54] (54,64]    65+
## x2 y2                                                     
## H  FALSE      33498  159737  181957  162409  130940 173849
##    TRUE       55454    5136     408     151     143    139
## M  FALSE      24872  144742  170772  164745  138275 249323
##    TRUE       58098    9914    2246     997    1033    617
## 
## $measures
## NULL
</code></pre>

<pre><code class="r">#relative values, with measures, plotting
compareMultivar(var1A=var1A,var1B=var1B,var2A=var2A,var2B=var2B,var3A=var3A,var3B=var3B,fileA=fileA, fileB=fileB, type=&quot;rel&quot;,measures=TRUE,wA=wA, wB=wB, plot=TRUE)
</code></pre>

<p><img src="figure/concordancia2var1.png" alt="plot of chunk concordancia2var"/> <img src="figure/concordancia2var2.png" alt="plot of chunk concordancia2var"/> </p>

<pre><code>## $`table for file #1`
##          z1 (15,24] (24,34] (34,44] (44,54] (54,64]   65+
## x1 y1                                                    
## H  FALSE       2.19    8.28    9.67    8.41    7.22  9.34
##    TRUE        2.76    0.71    0.13    0.39    0.05  0.04
## M  FALSE       1.96    8.06    8.87    8.58    7.35 11.80
##    TRUE        2.69    0.62    0.51    0.20    0.11  0.07
## 
## $`table for file #2`
##          z2 (15,24] (24,34] (34,44] (44,54] (54,64]   65+
## x2 y2                                                    
## H  FALSE       1.79    8.54    9.73    8.69    7.00  9.30
##    TRUE        2.97    0.27    0.02    0.01    0.01  0.01
## M  FALSE       1.33    7.74    9.13    8.81    7.40 13.34
##    TRUE        3.11    0.53    0.12    0.05    0.06  0.03
## 
## $measures
##     tvd overlap   Bhatt    Hell 
## 0.03319 0.96681 0.99588 0.06418
</code></pre>

<p><em>Assess predictive value of concordant variables</em></p>

<p><strong>Function: predictvalue</strong></p>

<p>For each common variable found to be concordant between the files, we assess its predictive value with respect to the chosen specific variables. One variable at a time.</p>

<p>Note that in each assessment, only one of the files is used, i.e. the one that contains the specific variable to predict.</p>

<pre><code class="r">#choose values
varA &lt;- &quot;EST&quot; #variable to assess, name in file B
data &lt;- pra
varw &lt;- &quot;calELE&quot;
#
#table with absolute values, no measures, no plotting
predictvalue(varx=varA, vary=vary, data=data,varw=varw,plot=FALSE,measures=FALSE,type=&quot;abs&quot;)
</code></pre>

<pre><code>## $Table
##        y
## x       Occupied Unemployed (unpaid work) Unemployed (strict)
##   FALSE   934865                    48577               38391
##   TRUE     12506                     3285                   0
##   Sum     947371                    51862               38391
##        y
## x       Non-active (unpaid work, students) Inactive or retired     Sum
##   FALSE                             508594              204692 1735119
##   TRUE                              117930                 615  134336
##   Sum                               626524              205307 1869455
## 
## $Measures
## [1] &quot;measured not requested&quot;
</code></pre>

<pre><code class="r">#table with relative values, measures, plotting
predictvalue(varx=varA, vary=vary, data=data,varw=varw,plot=TRUE,measures=TRUE,type=&quot;rel&quot;)
</code></pre>

<p><img src="figure/predictvalue.png" alt="plot of chunk predictvalue"/> </p>

<pre><code>## $Table
##        y
## x       Occupied Unemployed (unpaid work) Unemployed (strict)
##   FALSE    53.88                     2.80                2.21
##   TRUE      9.31                     2.45                0.00
##   Sum      63.19                     5.25                2.21
##        y
## x       Non-active (unpaid work, students) Inactive or retired    Sum
##   FALSE                              29.31               11.80 100.00
##   TRUE                               87.79                0.46 100.01
##   Sum                               117.10               12.26 200.01
## 
## $Measures
## $Measures$V
##    y.x 
## 0.3219 
## 
## $Measures$lambda
##    y.x 
## 0.1143 
## 
## $Measures$tau
##     y.x 
## 0.05982 
## 
## $Measures$U
##     y.x 
## 0.04586
</code></pre>

<p><strong>Function: uncertvarxvary</strong></p>

<p>Otra opción interesante para la selección de variables es el cálculo de bandas de incertidumbre. La idea es seleccionar las variables comunes que más reduzcan la incertidumbre (anchura de las bandas) el relacionar las variables específicas de las encuestas.</p>

<pre><code class="r">data1 &lt;- ecv
data2 &lt;- pra
basedata &lt;- pra
varw1 &lt;- &quot;calELE&quot;
varw2 &lt;- &quot;calELE&quot;
varx &lt;- varEsp[1]
vary &lt;- &quot;PRA22&quot;
varlist &lt;- varCom[1:7] #restricted list of common variables, just to check
varlist
</code></pre>

<pre><code>## [1] &quot;ED&quot;  &quot;S&quot;   &quot;TF2&quot; &quot;EST&quot; &quot;OCP&quot; &quot;PAR&quot; &quot;INA&quot;
</code></pre>

<pre><code class="r">uncertvarxvary(varx=varx,vary=vary,data1=data1,data2=data2,basedata=basedata,varw1=varw1,varw2=varw2,varlist=varlist)
</code></pre>

<pre><code>## $Best
## [1] &quot;|ED+S+TF2+EST+OCP+PAR&quot;
## 
## $NumberVariables
## [1] 6
## 
## $NumberCells
## [1] 288
## 
## $OvUncert
## [1] 0.05638
</code></pre>

<p><strong>NOTE</strong>
Note that warnings are generated because observed distributions are not concordant between the files when crossing so many variables. Uncertainty evaluation might make more sense in specific stratum and with less variables, controlling that a minimum level of coherence between the sources is satisfied.</p>

<h3>Etapa 3: Aplicar un método de enlace</h3>

<p><strong>Function: nnhdbystrata</strong></p>

<p>Generalmente, el enlace se hará por estratos. En el caso de ECV-PRA hemos usado 12 grupos de edad y sexo, y dentro de cada uno se ha realizado un hot-deck independiente, usando variables distintas cada vez.</p>

<p>Mostramos un ejemplo.</p>

<pre><code class="r">#check documentation ?nnhdbystrata
#select stratum
i &lt;- 1 ##select here: values between 1-12
strata &lt;- as.factor(levels(ecv$EDS))
strata.sel &lt;- strata[i]
strata.sel #this is selected stratum
</code></pre>

<pre><code>## [1] H.(15,24]
## 12 Levels: H.(15,24] H.(24,34] H.(34,44] H.(44,54] H.(54,64] ... M.65+
</code></pre>

<pre><code class="r">#
#Select variables for this stratum 
# The decision must be grounded on the previous phase
matchvars &lt;- c(&quot;EST&quot;, &quot;BUSQ&quot;)
matchvars
</code></pre>

<pre><code>## [1] &quot;EST&quot;  &quot;BUSQ&quot;
</code></pre>

<pre><code class="r">#
#donante y receptor
don &lt;- pra[which(pra$EDS  == strata.sel ), ]
rec &lt;- ecv[which(ecv$EDS  == strata.sel ), ]
wA &lt;- wB &lt;- &quot;calELE&quot;
vary &lt;- &quot;PRA22&quot;
#
fused.1 &lt;- nnhdbystrata(rec=rec,don=don,stratalevel=strata.sel,stratavar=&quot;EDS&quot;,matchvars=matchvars,vary=vary, checkdiffs=TRUE)
</code></pre>

<pre><code>##          fused$EST.don
## fused$EST FALSE TRUE
##     FALSE    69    0
##     TRUE      0   88
##           fused$BUSQ.don
## fused$BUSQ FALSE TRUE
##      FALSE   133    0
##      TRUE      2   22
</code></pre>

<pre><code class="r">#
#check output (a data frame with fused file)
#str(fused.1)
#names(fused.1) ## ECV con la variable PRA22 adicional
dim(fused.1) #only for strata #1
</code></pre>

<pre><code>## [1] 157 418
</code></pre>

<p><strong>NOTE #1</strong>
Note that the by setting the logical parameter checkdiff to TRUE, a table is generated for each selected matching variable to check for differences between the values in that variable for the recipient-donor files. If all values are placed in the diagonal then all recipient-donor pairs will be equal in that variable.</p>

<p><strong>NOTE #2</strong>
In this example, the fused file was only obtained for the first stratum. The usage is to perform hot-deck for all the strata, store results in 12 data frames and then appy rbind to get a fused file with all the rows of the original recipient file.</p>

<h3>Etapa 4: Validar resultados</h3>

<p>The same functions used for variable selection (concordance assessment) can be used to compare distributions of observed/imputed variables. Thus, these function belong to two families in the package.</p>

<p><strong>Function: compareVar</strong></p>

<pre><code class="r">#compare observed/imputed distributions
varA &lt;- varB &lt;- &quot;PRA22&quot;
wA &lt;- wB &lt;- &quot;calELE&quot;
fileA &lt;- fused.1
fileB &lt;- don
#
compareVar(varA=varA,varB=varB,fileA=fileA,fileB=don,wA=wA,wB=wB,plot=TRUE,type=&quot;rel&quot;,measures=TRUE)
</code></pre>

<pre><code>## ymax not defined: adjusting position using y instead
</code></pre>

<p><img src="figure/validateResults.png" alt="plot of chunk validateResults"/> </p>

<pre><code>## $`table for file #1`
## x1
##                           Occupied           Unemployed (unpaid work) 
##                              30.47                               3.72 
##                Unemployed (strict) Non-active (unpaid work, students) 
##                               8.42                              52.41 
##                Inactive or retired                                Sum 
##                               4.98                             100.00 
## 
## $`table for file #2`
## x2
##                           Occupied           Unemployed (unpaid work) 
##                              25.22                               1.98 
##                Unemployed (strict) Non-active (unpaid work, students) 
##                               7.63                              60.45 
##                Inactive or retired                                Sum 
##                               4.72                             100.00 
## 
## $measures
##     tvd overlap   Bhatt    Hell 
## 0.08042 0.91958 0.99585 0.06443
</code></pre>

<p><strong>Function: compareMultivar</strong></p>

<pre><code class="r">#compare observed/imputed distributions by levels of a second variable
var1A &lt;- var1B &lt;- &quot;PRA22&quot;
var2A &lt;- var2B &lt;- &quot;EST&quot;
wA &lt;- wB &lt;- &quot;calELE&quot;
fileA &lt;- fused.1
fileB &lt;- don
compareMultivar(var1A=var1A,var1B=var1B,var2A=var2A,var2B=var2B,fileA=fileA,fileB=fileB,wA=wA,wB=wB,plot=TRUE,type=&quot;rel&quot;,measures=TRUE)
</code></pre>

<p><img src="figure/unnamed-chunk-11.png" alt="plot of chunk unnamed-chunk-1"/> <img src="figure/unnamed-chunk-12.png" alt="plot of chunk unnamed-chunk-1"/> </p>

<pre><code>## $`table for file #1`
##                                    y1 FALSE  TRUE
## x1                                               
## Occupied                              27.28  3.19
## Unemployed (unpaid work)               1.45  2.27
## Unemployed (strict)                    8.42  0.00
## Non-active (unpaid work, students)     2.13 50.28
## Inactive or retired                    4.98  0.00
## 
## $`table for file #2`
##                                    y2 FALSE  TRUE
## x2                                               
## Occupied                              22.35  2.87
## Unemployed (unpaid work)               1.32  0.66
## Unemployed (strict)                    7.63  0.00
## Non-active (unpaid work, students)     1.87 58.58
## Inactive or retired                    4.48  0.24
## 
## $measures
##     tvd overlap   Bhatt    Hell 
## 0.08537 0.91463 0.99334 0.08163
</code></pre>

<h2>Extensions: What if we create a new, specific class for matching?</h2>

<p><em>Class: matchdesign</em></p>

<p>Define a matchdesign class that encapsulates the type of matching that we want.
To this class, we will pass:</p>

<ul>
<li>recipient file A</li>
<li>donor file B</li>
<li>Common variables (both in A &amp; B)</li>
<li>Specific variables in A</li>
<li>Specific variables in B</li>
</ul>

<pre><code class="r">rec &lt;- ecv
don &lt;- pra
matchvars &lt;- varCom[-c(1,2)]#Eliminamos ED, S que son de estrato
donvars &lt;- c(&quot;PRA22&quot;) #variable especifica de PRA, la unica que se considera: PRA22
recvars &lt;- &quot;SAL&quot; #variable especifica de ECV, un ejemplo: SAL &#39;trastornos de salud&#39;
stratavar &lt;- &quot;ED&quot; #variable de estrato
d1 &lt;- new(&quot;matchdesign&quot;,rec=rec, 
                don=don, 
                matchvars=matchvars, 
                donvars=donvars,
                recvars=recvars,
                stratavar=stratavar
)
class(d1) #comprobacion de que la clase es &#39;matchdesign&#39;
</code></pre>

<pre><code>## [1] &quot;matchdesign&quot;
## attr(,&quot;package&quot;)
## [1] &quot;micromatch&quot;
</code></pre>

<p>Dos métodos sencillos</p>

<p><strong>Method: Describe</strong></p>

<p><strong>Method: Compare1</strong></p>

<p><em>describe</em> nos devuelve los parámetros especificados en matchdesign
<em>compare1</em> realiza un cálculo rápido de distancias de Hellinger para cada variable común especificada en matchdesign, por separado (sin considerar estratos)</p>

<pre><code class="r">describe(d1)
</code></pre>

<pre><code>## $`Number of receptor rows:`
## [1] 4749
## 
## $`Number of donor rows:`
## [1] 10865
## 
## $`Common matching variables:`
## [1] &quot;TF2&quot;      &quot;EST&quot;      &quot;OCP&quot;      &quot;PAR&quot;      &quot;INA&quot;      &quot;BUSQ&quot;    
## [7] &quot;DOM.com2&quot;
## 
## $`Specific vars receptor file:`
## [1] &quot;SAL&quot;
## 
## $`Specific vars donor file:`
## [1] &quot;PRA22&quot;
## 
## $`Strata variable:`
## [1] &quot;ED&quot;
</code></pre>

<pre><code class="r">compare1(x=d1)
</code></pre>

<pre><code>##     varCom    tvd overlap  Bhatt   Hell
## 1      TF2 0.0739  0.9261 0.9943 0.0752
## 2      EST 0.0086  0.9914 0.9999 0.0122
## 3      OCP 0.0081  0.9919      1 0.0057
## 4      PAR  0.006   0.994 0.9999 0.0099
## 5      INA 0.0021  0.9979      1 0.0015
## 6     BUSQ 0.0121  0.9879 0.9997 0.0173
## 7 DOM.com2 0.0648  0.9352 0.9978 0.0466
</code></pre>

<h3>Probar con otros datos externos</h3>

<p><strong>Datos del INE</strong></p>

<ol>
<li>EPA: Encuesta de poblacion activa
Filtramos los mayores de 16 y datos de Euskadi, para poder comparar con PRA</li>
<li>EES: Encuesta de estructura salarial</li>
</ol>

<pre><code class="r">#cargar datos del INE
#microdatos ya descargados desde la web
library(MicroDatosEs)
setwd(&quot;~/Documents/micromatch-ejemplosUso/datosINE&quot;)
epa4T2009 &lt;- epa2005( epa.file = &quot;datos_t409&quot; )
#
#Filtrar: 
## datos de Eusadi, mayores de 16
nrow(epa4T2009[which(epa4T2009$ccaa==16 &amp; epa4T2009$nivel==1 ),]) #con 16 anyos o mas
epa &lt;- epa4T2009[which(epa4T2009$ccaa==16 &amp; epa4T2009$nivel==1 ),]
#
setwd(&quot;~/Documents/micromatch&quot;)
</code></pre>

<h2>References</h2>

<ul>
<li>A. Leulescu &amp; M. Agafitei, <em>Statistical matching: a model based approach for data integration</em>, Eurostat methodolgies and working papers, 2013.</li>
<li><em>Data Integration</em> ESSnet project (<a href="http://www.cros-portal.eu/content/data-integration-finished">http://www.cros-portal.eu/content/data-integration-finished</a>)</li>
<li><em>ISAD</em> ESSnet project (<a href="http://www.cros-portal.eu/content/isad-finished">http://www.cros-portal.eu/content/isad-finished</a>)</li>
<li><em>Statistical Matching, Theory and Practice</em>, Marcello D&#39;Orazio, Marco Di Zio, Mauro Scanu, Wiley, 2006.</li>
<li><em>Statistical Matching: A Frequentist Theory, Practical Applications and Alternative Bayesian Approaches (Lecture Notes in Statistics)</em>, S. Rässler, Springer, 2002.</li>
</ul>

</body>

</html>

